---
title: "Руководство Эмиллера по разработке модулей для Nginx"
description: "Первая попытка перевести это эпическое произведение."
categories: [общее]
layout: post
time: 02:38:35
---
<style type="text/css">
div.figure
{
	margin: 2em;
	text-align: center;
}
div.figure img { display: block; margin: 0 auto 1em; }
</style>

<section>
<small>Оригинал <a href="http://www.evanmiller.org/nginx-modules-guide.html">Emiller's Guide To Nginx Module Development</a>, черновик от 14 июля 2008 г. (<a href="http://www.evanmiller.org/nginx-modules-guide.html#changes">изменения</a>).
Автор: <a href="http://www.evanmiller.org/">Эван Миллер</a>, перевод <a href="/">Петра Леонова</a>.</small>
</section>

<section>
<ul>
<li><span style="font-variant: small-caps;">Брюс Уэйн</span>: <em>Что это?</em></li>
<li><span style="font-variant: small-caps">Люциус Фокс</span>: <em>Бэтмобиль? Ох… лучше вам не знать.</em></li>
</ul>
</section>

<section>
<p>Чтобы лучше разобраться в Nginx'е, web-сервере, надо сначала понять Бэтмена, персонажа комиксов.</p>

<p>Бэтмен быстр. Nginx быстр. Batman борется с преступностью. Nginx борется с лишней нагрузкой на процессор и утечками памяти. Бэтмен хорошо держится под натиском врага. Nginx, в свою очередь, держится превосходно при очень большой нагузке на сервер.</p>

<p>Но кем бы был Бэтмен без своего <strong>Пояса</strong>.</p>
<div class="figure">
	<img src="i/utility-belt.jpg" alt="Пояс Бэтмена"/> 
	<strong>Рисунок 1</strong>: Пояс Бэтмена, в обнимку с пузом Кристиана Бэйла.
</div>

<p>В любой момент в Поясе Бэтмена может найтись набор отмычек, пара бумерангов, бэт-наручники, бэт-маячок, бэт-дротик, прибор ночного видения, термитные гранаты, дымовая завеса, фонарик, обруч из криптонита, паяльная лампа или iPhone. Если Бэтмену надо кого-то усыпить, ослепить, оглушить, выследить, пристукнуть, притормозить, довести до слез или заэсэмэсить насмерть, то он тянется к своему Поясу. Для Бэтмена он так много значит, что он скорей забыл бы одеть штаны, чем пояс. А у Бэтмена штанов и нет, вместо них ему приходится носить резиновые бронеритузы (рис. 1).</p>

<p>Вместо Пояса Бэтмена у Nginx имеется свой <strong>набор модулей</strong>. Когда нужно сжать запрос или передать его по частям, Nginx запускает соответсвующий модуль. Когда Nginx блокирует доступ с какого-либо IP адреса или проверяет данные HTTP-авторизации, на самом деле это делает один из модулей. Если Nginx подсоединяется к Memcache или FastCGI-серверу, то именно модуль связывает их.</p>

<p>Пояс Бэтмена напичкан всякими полезностями, но иногда Бэтмену нужно что-то новенькое. Например, обнаружился новый противник, которого не удержать бэт-наручниками и не сломить бумерангом. Или Бэтмену скоро пригодится новая способность, такая как способность дышать под водой. Вот тогда-то Бэтмен и зовет <strong>Люциуса Фокса</strong>, чтобы тот придумал новую бэт-штуковину.</p>

<div class="figure">
	<img src="i/lucius.jpg" alt="Люциус Фокс"/> 
	<strong>Рисунок 2</strong>: Брюс Уэйн (он же Бэтмен) со своим инженером Люциусом Фоксом.
</div>


<p>Целью этого руководства является подробно рассказать вам о модулях Nginx, чтобы вы смогли стать как Люциус Фокс. После прочтения руководства вы сможете проектировать и реализовывать отличные модули, которые помогут Nginx делать то, чего он раньше не умел. Система модулей Nginx содержит много ньюансов и особенностей, так что вы, наверно, будете часто возвращаться к этому руководству. Я постарался изложить концепции настолько доступно, насколько это возможно. но, без сомнений, создание модулей для Nginx все равно остается трудной задачей.</p>

<p>Но кто говорил, что создавать бэт-штуковины будет легко?</p>
</section>
	
<section>
<h>Содержание</h>
<ol>
	<li><a href="#prerequisites">Для начала</a></li>
	<li><a href="#overview">Устройство модулей в первом приближении</a></li>
	<li>
		<a href="#components">Компоненты модуля Nginx</a>
		<ol>
			<li><a href="#configuration-structs">Структуры конфигурации модуля</a></li>
			<li><a href="#directives">Директивы модуля</a></li>
			<li>
				<a href="#context">Контекст модуля</a>
				<ol>
					<li><a href="#create_loc_conf">create_loc_conf</a></li>
					<li><a href="#merge_loc_conf">merge_loc_conf</a></li>
				</ol>
			</li>
			<li><a href="#definition">Описание модуля</a></li>
			<li>
				<a href="#installation">Установка модуля</a>
				<ol>
					<li><a href="#handler-installation">Установка обработчика</a></li>
					<li><a href="#filter-installation">Установка фильтра</a></li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
		<a href="#types">Обработчики, фильтры и балансировщики нагрузки</a>
		<ol>
			<li>
				<a href="#non-proxying">Устройство обработчиков (не проксирующих)</a>
				<ol>
					<li><a href="#non-proxying-config">Получение конфигурации локейшна</a></li>
					<li><a href="#non-proxying-response">Генерация ответа</a></li>
					<li><a href="#non-proxying-header">Отправка заголовка ответа</a></li>
					<li><a href="#non-proxying-body">Отправка тела ответа</a></li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<section>
<a name="prerequisites"></a>
<h>Для начала</h>
<p>Вы должны неплохо знать Си. Не просто его синтаксис, а то, как работать со структурами и не бояться указателей и ссылок на функции. А также иметь представление о препроцессоре и макросах. Если вам надо немного освежить знания, то ничто не сможет сравниться с <a href="http://en.wikipedia.org/wiki/The_C_Programming_Language_(book)">K&amp;R</a>(англ.).</p>

<p>Полезно понимать основы HTTP. Мы же, вообще-то, собираемся работать с web-сервером.</p>

<p>Пригодятся знания структуры конфигурационного файла Nginx'а. Вот основные моменты: существуют четыре <em>контекста</em> (называеются они <em>main</em> — главный, <em>server</em> — сервер, <em>upstream</em> — апстрим, и <em>location</em> — локейшн) в которых могут быть директивы с одним и более параметрами. Директивы в главном контексте применяются ко всему-всему; директивы из котекста сервера применяются к конкретному хосту/порту; директивы в апстриме описывают набор бэкендов; а директивы в контексте локешна применяются к разным путям запроса (например, "/", "/images" и т.д.) Локешн наследует конфигурацию содержащему его серверному контексту, а сервер наследует главному контексту. Контекст апстрима не наследует никому, у него собственные директивы, которых больше нигде не используются. Я буду иногда упоминать эти четыре контекста, так что… не забывайте про них.</p>

<p>Ну что же, начнем!</p>

<section>
<a name="overview"></a>
<h>1. Устройство модулей в первом приближении</h>
У модулей Nginx'a могут быть три роли, которые мы рассмотрим:
<ul>
	<li><em>обработчики</em> обрабатывают запрос и генерируют данные ответа</li>
	<li><em>фильтры</em> обрабатывают данные, полученные от обработчика</li>
	<li><em>балансировщики</em> выбирают бэкенд, которому передать запрос, если определено несколько бэкендов</li>
</ul>

<p>Модули делают реальную работу, которую обычно делают web-серверы: когда Nginx отправляет файл или проксирует запрос к другому серверу, то это делает модуль-обработчик. Когда Nginx гзипит данные или обрабатывает SSI-директивы, он делает это с помощью модуля-фильтра. Ядро Nginx'а берет на себя работу с сетью и реализацию протоколов, а также запускает модули, которые необходимы для обработки запроса. Децентрализованная архитектура позволяет нам создавать отдельные компоненты, которые делают что-то, что нам нужно.</p>

<p>Замечание: в отличие от модулей Apache, модули Nginx'а <em>не</em> подгружаются динамически (другими словами, модули вкомпилированы прямо в бинарник Nginx'а).</p>

<p>Как же тогда модули задействуются? Обычно, на стадии загрузки сервера каждый обработчик получает шанс прикрепиться к каким-либо локейшнам из конфигурационного файла. Если несколько обработчиков попробуют занять один локейшн, то победит только один (в хорошем конфиге такого не произойдет). Обработчик может завершиться с тремя результатами: все хорошо, произошла ошибка, или он может отказаться от обработки локешна в пользу обработка по умолчанию (обычно, это выдача статических файлов).</p>

<p>Если обработчик является реверс-прокси, то ему понадобится помощь балансировщика нагрузки. Балансировщик получает запрос вместе с набором бэкендов и принимает решение, какому серверу передать запрос. Nginx поставлется с двумя модулями балансировки: round-robin, который выбирает серверы по очереди, и модуль с методом хеширования IP адреса, который гарантирует, что запрос конкретного клиента каждый раз будет передаваться одному и тому же бэкенду.</p>

<p>Если обработчик не вернул ошибку, управление перейдет к фильтрам. Один локешн могут фильтровать несколько модулей, так, например, ответ может быть сжат, а потом выдаваться chunk'ами. Порядок запуска фильтров определяется на этапе компиляции. Фильры используют классический паттерн «<a href="http://ru.wikipedia.org/wiki/Chain_of_Responsibility">цепочка обязанностей</a>»: запускается один фильтр, делает свою работу, потом запускается второй, и так далее, пока не выполнится последний фильтр, и Nginx завершит обработку запроса.</p>

<p>Самая вкусная особенность цепочки фильтров заключается в том, что один фильтр не должен ждать, пока другой завершит свою работу целиком. Можно начать обрабатывать результат работы предыдущего фильтра по мере поступления, почти как птоки (пайпы) в юниксе. Фильры оперируют <em>буферами</em>, размер которых, обычно, равен размеру страницы (4 Кб), но размер всегда можно задать в nginx.conf. Это означает, например, то, что что модуль может начать сжимать ответ и отправлять его клиенту еще до того, как бэкенд полностью передат данные ответа. Чудесно!</p>

Чтобы увидеть картину в целом, рассмотрим типичный цикл обработки запроса:
<ol>
	<li>клиент посылает HTTP-запрос;</li>
	<li>Nginx выбирает подходящий обработчик на основе конфига;</li>
	<li>балансировщик (если необходимо) выбирет бэкенд;</li>
	<li>обработчик делает свое дело и передает каждый буфер с данными результата первому фильтру;</li>
	<li>фильтр передает результаты второму фильтру;</li>
	<li>второй — третьему, третий — четвертому, и так далее;</li>
	<li>получившийся ответ отправляется клиенту.</li>
</ol>

Я сказал «типичный» цикл потому, что обработку в Nginx'е можно настраивать как угодно. Определить когда и как должен запускать модуль может оказаться непростой задачей для разработчика (я бы сказал очень даже не простой задачей). Настройка модуля проходит в следствии вызова ряда колбеков, и их не так уж мало. Конкретно, можно определить функцию, которая будет запущена:
<ul>
	<li>Прямо перед чтением конфигурационного файла</li>
	<li>Для каждой директивы конфигурации локешна или сервера по мере их поступления</li>
	<li>Когда Nginx инициализирует главную конфигурацию</li>
	<li>Когда Nginx инициализирует конфигурацию сервера (хост/порт)</li>
	<li>Когда Nginx мерджит конфигурацию сервера с главной конфигурацией</li>
	<li>Когда Nginx инициализирует конфигурацию локешна</li>
	<li>Когда Nginx мерджит конфигурацией сервера с вложенной конфигурацией локешна</li>
	<li>Когда запускается главный процесс Nginx'а</li>
	<li>Когда запускается новый рабочий процесс</li>
	<li>Когда рабочий процесс завершается</li>
	<li>Когда главный процесс завершается</li>
	<li>Для обработки запроса</li>
	<li>Для фильтрации заголовка ответа</li>
	<li>Для фильтрации тела ответа</li>
	<li>Для выбора бэкенда</li>
	<li>В момент инициализации запроса к бэкенда</li>
	<li>В момент <em>пере</em>инициализации запроса к бэкенду</li>
	<li>Для обработки ответа от бэкенда</li>
	<li>В момент завершения работы с бэкендом</li>
</ul>

<p>Боже мой! Это может смутить. В вашем распоряжении большая мощь, но можно начать делать что-то полезное, используя всего несколько хуков и соответсвующих функций. Время погрузиться в модули Nginx'а.</p>

<section>
<a name="components"></a>
<h>2. Компоненты модуля Nginx</h>

<p>Как я уже сказал, в вашем распоряжении <em>огромный</em> запас гибкости для разработки модуля для Nginx'а. В этом разделе те части, которые есть практически в любом модуле. Это моможет нам лучше понять устройство модуля. А так же вы сможете оценить, когда можно будет перейти к написанию собственного модуля.</p>

<section>
<a name="configuration-structs"></a>
<h>2.1. Структуры конфигурации модуля</h>

Модуль можно описать с помощью трех разных конфигурационных структур, по одной для главного контекста, контекста сервера и контекста локешна. Большинству модулей достаточно конфигурации локешна. Для структур принято такое именование: <code>ngx_http_&lt;название_модуля&gt;_(main|srv|loc)_conf_t</code>. Вот пример, взятый из модуля <code>dav</code>:
<code>
<pre><code class="cpp">
typedef struct {
    ngx_uint_t  methods;
    ngx_flag_t  create_full_put_path;
    ngx_uint_t  access;
} ngx_http_dav_loc_conf_t;
</code></pre>
</code>

<p>Заметьте, что в Nginx'е используются специальные типы данных (<code>ngx_uint_t</code> и <code>ngx_flag_t</code>). Это просто алиасы для простых типов данных, которые мы все знаем и любим (см. <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_config.h#L79">core/ngx_config.h</a>, если есть сомнения).</p>


Элементы конфигурационной структуры заполняются значениями, описывающими модуль.

<a name="directives"></a>
<h3>2.2. Директивы модуля</h3>
Директивы описыватся в статическом массиве элементов типа <code>ngx_command_t</code>. Вот пример того, как их определять (взят из маленького модуля, который я написал):

<code>
<pre><code class="cpp">
static ngx_command_t  ngx_http_circle_gif_commands[] = {
    { ngx_string("circle_gif"),
      NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
      ngx_http_circle_gif,
      NGX_HTTP_LOC_CONF_OFFSET,
      0,
      NULL },

    { ngx_string("circle_gif_min_radius"),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_num_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_circle_gif_loc_conf_t, min_radius),
      NULL },
      ...
      ngx_null_command
};
</code></pre>
</code>

 

 
А вот определение структуры <code>ngx_command_t</code> (той, что мы сейчас заполняем), оно взято из файла <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_conf_file.h#L77">core/ngx_conf_file.h</a>:

<code>
<pre><code class="cpp">
struct ngx_command_t {
    ngx_str_t             name;
    ngx_uint_t            type;
    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
    ngx_uint_t            conf;
    ngx_uint_t            offset;
    void                 *post;
};
</code></pre>
</code>

 

 
На первый взгляд слишком много, но у каждого поля свое назначение.

В <code>name</code> хранится имя директивы, обязательно без пробелов. Используется тип <code>ngx_str_t</code>, значение которого чаще всего создаются с помощью макроса <code>ngx_str("proxy_pass")</code>. Замечание: структура <code>ngx_str_t</code> состоит из поля <code>data</code>, которое содержит саму строку, и поля <code>len</code>, в котором хранится длина строки. В большинстве случаев Nginx использует эту структуру взамен обычных строк.

Значение <code>type</code> задается с помощью набора флагов, которые определяют, где можно использовать эту директиву, и сколько она принимает параметров. Значение получается с помощью бинарного или:
<ul>
	<li><code>NGX_HTTP_MAIN_CONF</code>: разрешает использовать директиву в главном контексте</li>
	<li><code>NGX_HTTP_SRV_CONF</code>: в контексте сервера (хоста)</li>
	<li><code>NGX_HTTP_LOC_CONF</code>: в контексте локешна</li>
	<li><code>NGX_HTTP_UPS_CONF</code>: в контексте апстрима</li>
</ul>
<ul>
	<li><code>NGX_CONF_NOARGS</code>: сообщает, что директива не принимает аргументы</li>
	<li><code>NGX_CONF_TAKE1</code>: принимает ровно 1 аргументы</li>
	<li><code>NGX_CONF_TAKE2</code>: принимает ровно 2 аргумента</li>
	<li>…</li>
	<li><code>NGX_CONF_TAKE7</code>: принимает ровно 7 аргументов</li>
</ul>
<ul>
	<li><code>NGX_CONF_FLAG</code>: тип аргумента должен быть булев??? ("on" или "off")</li>
	<li><code>NGX_CONF_1MORE</code>: директиве принимает 1 или более аргументов</li>
	<li><code>NGX_CONF_2MORE</code>: директиве принимает 2 или более аргументов</li>
</ul>
Есть еще несколько опций, спотрите <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_conf_file.h#L1">core/ngx_conf_file.h</a>.

В элементе структуры <code>set</code> хранится указатель на функцию, вызываемую для настройки какой-то части модуля; обычно, эта функция преводит данные из аргументов в удобный формат и сохраняет их в соответстующей структуре конфигурации модуля. Функция принимает три аргумента:
<ol>
	<li>указатель на структуру <code>ngx_conf_t</code>, которая содержит переданные директиве аргументы</li>
	<li>указатель на текущую структуру <code>ngx_command_t</code></li>
	<li>указатель на собственную структуру конфигурации модуля</li>
</ol>
Функция будет вызвана тогда, когда соответствующая директива будет встречена в конфигурационном файле. Nginx предосталяет набор функций для перевода разных типов параметров в структуру для последующей обработки. Среди этих функций хочу виделить следуюющие:
<ul>
	<li><code>ngx_conf_set_flag_slot</code>: переводит "on" или "off" в 1 или 0</li>
	<li><code>ngx_conf_set_str_slot</code>: певодит строку параметра в <code>ngx_str_t</code></li>
	<li><code>ngx_conf_set_num_slot</code>: парсит число и возвращает его как <code>int</code></li>
	<li><code>ngx_conf_set_size_slot</code>: парсит размер ("8k", "1m" и т.д.) и возвращает его как <code>size_t</code></li>
</ul>
Есть еще несколько функций, и они тоже очень удобны (посотрите <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_conf_file.h#L329">core/ngx_conf_file.h</a>). Модули могут описывать здесь и свои функции, если по каким-то причинам не достаточно встроенных.

Откуда эти функции узнают, куда сохранять данные? В этом им помогают следующие два свойстваструктуры <code>ngx_command_t</code>: <code>conf</code> и <code>offset</code>. <code>conf</code> указывае Nginx'у куда сохранить данные: в главную, серверную или конфигурационную структуру локешна (задается с помощью <code>NGX_HTTP_MAIN_CONF_OFFSET</code>, <code>NGX_HTTP_SRV_CONF_OFFSET</code>, or <code>NGX_HTTP_LOC_CONF_OFFSET</code>). <code>offset</code> указывает в какую часть структуры записать значение.

И,<em>наконец</em>, <code>post</code> это еще одна штукенция, которая может пригодится модулю на этапе конфигурации. Чаще всего равна <code>NULL</code>.

Набор директив заканчивается <code>ngx_null_command</code>.

<a name="context"></a>
<h3>2.3. Контекст модуля</h3>
Это статическая структура типа <code>ngx_http_module_t</code>, в которой определяются несколько указателей на функции для создание трех конфигураций и сливания их вместе. Называют ее <code>ngx_http_&lt;имя_модуля&gt;_module_ctx</code>. Вот назначение этих функций по порядку:
<ul>
	<li>перед конфигурацией</li>
	<li>после конфигурации</li>
	<li>создание главной конфигурации (то есть выделение памяти и задание значений по умолчанию)</li>
	<li>инициализация главной конфигурации (переопределение данных на взятые из nginx.conf)</li>
	<li>создание конфигурации сервера</li>
	<li>сливание ее с главной конфигурацие</li>
	<li>создание конфигурации локешна</li>
	<li>сливание ее с конфигурацие сервера</li>
</ul>
Функции принимают разные аргументы в зависимости от своего назначения. Вот описание этой структуры, взятое из <a class="source" href="http://www.riceonfire.org/lxr/http/source/http/ngx_http_config.h#L22">http/ngx_http_config.h</a>, в котором видны разные сигнатуры функций-колбеков:

<code>
<pre><code class="cpp">
typedef struct {
    ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);
    ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);

    void       *(*create_main_conf)(ngx_conf_t *cf);
    char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

    void       *(*create_srv_conf)(ngx_conf_t *cf);
    char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void *conf);

    void       *(*create_loc_conf)(ngx_conf_t *cf);
    char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void *conf);
} ngx_http_module_t;
</code></pre>
</code>

 

 
Указатели на те функции, которые вам не пригодятся, можете заполнить <code>NULL</code>, и Nginx сделает вид, что не заметил их.

Большинство обработчиков используют только две последние: чтобы выделить память для структуры конфигурации (называется <code>ngx_http_&lt;имя_модуля&gt;_create_loc_conf</code>), и слить ее с конфигурацией выше (называется <code>ngx_http_&lt;имя_модуля&gt;_merge_loc_conf</code>). Функция, сливающая вместе конфиги, также может вернуть ошибку, что остановит загрузку сервера.

Вот пример пример структуры контекста модуля:

<pre><code class="cpp">
static ngx_http_module_t  ngx_http_circle_gif_module_ctx = {
    NULL,                          /* перед конфигурацией */
    NULL,                          /* после конфигурации */

    NULL,                          /* создание главной конфигурации */
    NULL,                          /* инициализация главной конфигурации */

    NULL,                          /* создание конфигурации сервера */
    NULL,                          /* сливание ее с главной конфигурацие */

    ngx_http_circle_gif_create_loc_conf,  /* создание конфигурации локешна */
    ngx_http_circle_gif_merge_loc_conf /* сливание ее с конфигурацие сервера */
};
</code></pre>

 

 
Пришло время разобраться со всем этим подробнее. Эти конфигурационные колбеки очень похожи во всех модулях и используют одну часть Nginx API, так что их надо хорошо знать.

<a name="create_loc_conf"></a>
<h4>2.3.1. create_loc_conf</h4>
Вот так выглядит минимальная реализация функции <code>create_loc_conf</code>, взятая из моего модуля circle_gif (за подробностями прошу <a href="http://www.riceonfire.org/emiller/ngx_http_circle_gif_module.c.txt">в исходник</a>). Она получает структуру (<code>ngx_conf_t</code>) и возвращает вновь созданную структуру конфигурации модуля (в этом примере <code>ngx_http_circle_gif_loc_conf_t</code>).

<pre><code class="cpp">static void *
ngx_http_circle_gif_create_loc_conf(ngx_conf_t *cf)
{
    ngx_http_circle_gif_loc_conf_t  *conf;

    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_circle_gif_loc_conf_t));
    if (conf == NULL) {
        return NGX_CONF_ERROR;
    }
    conf-&gt;min_radius = NGX_CONF_UNSET_UINT;
    conf-&gt;max_radius = NGX_CONF_UNSET_UINT;
    return conf;
}</code></pre>

 

 
Прошу заметить важную особенность управления памятью в Nginx'е: он сам позаботится о вызове <code>free</code> только тогда, когда для выделения памяти вы используете <code>ngx_palloc</code> (умную обертку для <code>malloc</code>) или <code>ngx_pcalloc</code> (умную обертку для <code>calloc</code>).

Возможными вариантами задания UNSET являются: <code>NGX_CONF_UNSET_UINT</code>, <code>NGX_CONF_UNSET_PTR</code>, <code>NGX_CONF_UNSET_SIZE</code>, <code>NGX_CONF_UNSET_MSEC</code>, и для всех случаев <code>NGX_CONF_UNSET</code>. UNSET показывает функции сливания конфигов, что это значение надо переопределить.

<a name="merge_loc_conf"></a>
<h4>2.3.2. merge_loc_conf</h4>
Вот так выглядит функция сливания конфигов в модуле circle_gif:

<pre><code class="cpp">static char *
ngx_http_circle_gif_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_circle_gif_loc_conf_t *prev = parent;
    ngx_http_circle_gif_loc_conf_t *conf = child;

    ngx_conf_merge_uint_value(conf-&gt;min_radius, prev-&gt;min_radius, 10);
    ngx_conf_merge_uint_value(conf-&gt;max_radius, prev-&gt;max_radius, 20);

    if (conf-&gt;min_radius &lt; 1) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
            "min_radius должен быть больше или равен 1");
        return NGX_CONF_ERROR;
    }
    if (conf-&gt;max_radius &lt; conf-&gt;min_radius) {
        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
            "max_radius должен быть больше или равен min_radius");
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;
}
</code></pre>

 

 
Приятной особенностью Nginx'а является набор функций для сливания разных типов данных (<code>ngx_conf_merge_&lt;тип_данных&gt;_value</code>); их аргументами являются
<ol>
	<li>значение <em>текущего</em> локешна</li>
	<li>значение, задаваемое, если #1 не установлено</li>
	<li>задаваемое по умолчанию, если не установлено ни #1, ни #2</li>
</ol>
Результат будет записан в первый аргумент. Примерами таких функций являются <code>ngx_conf_merge_size_value</code>, <code>ngx_conf_merge_msec_value</code> и другие. Обратитесь к <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_conf_file.h#L254">core/ngx_conf_file.h</a> за полным списком.
<div class="aside">

А вот вопрос: как же этим функциям удается записать данные в первый аргумент, если он передается по значению?
Ответ прост: это макросы (они разворачиваются в несколько конструкций <code>if</code>).</div>
Интересно так же то, как эти функции обрабатывают ошибки. В случае неудачи в лог выводится сообщение, и функция возвращает <code>NGX_CONF_ERROR</code>. В этом случает запуск сервера прекращается. Так как сообщение выводится с уровнем <code>NGX_LOG_EMERG</code>, оно будет продублировано в поток ошибок. Кстати, <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_log.h#L1">core/ngx_log.h</a> содержит полный список уровнй вывода.)

<a name="definition"></a>
<h3>2.4. Описание модуля</h3>

Теперь добавим еще один уровель абстракции, структуру <code>ngx_module_t</code>. Переменную назовем <code>ngx_http_&lt;имя_модуля&gt;_module</code>. В ней описываются указатели на контекст и директивы модуля вместе с остальными колбеками(завершение треда, завершение процесса и т.д.). Определение модуля иногда используется, чтобы найти какие-либо данные, связанные с этим модулем. Определение модуля часто выглядит так:

<pre><code class="cpp">
ngx_module_t  ngx_http_&lt;имя_модуля&gt;_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_&lt;имя_модуля&gt;_module_ctx, /* контекст модуля */
    ngx_http_&lt;module name&gt;_commands,   /* директивы модуля */
    NGX_HTTP_MODULE,               /* тип модуля */
    NULL,                          /* инициализация мастера */
    NULL,                          /* инициализация модуля */
    NULL,                          /* инициализация процесса */
    NULL,                          /* инициализация треда */
    NULL,                          /* завершение треда */
    NULL,                          /* завершение процесса */
    NULL,                          /* завершение мастера */
    NGX_MODULE_V1_PADDING
};
</code></pre>

 

 

…замените &lt;имя_модуля&gt; на что-нибудь полезное. Модули погут определять колбеки для моментов создания и уничтожения процессов и тредов, но большинство модулей стараются не усложнять себе жизнь. Чтобы посмотреть список аргументов, обратитесь к <a class="source" href="http://www.riceonfire.org/lxr/http/source/core/ngx_conf_file.h#L110">core/ngx_conf_file.h</a>.)

<a name="installation"></a>
<h3>2.5. Установка модуля</h3>
Модули устанавливаются двумя способами: обработчики чаще всего устанавливаются колбеком директивы, а фильтры устанавливаются в постконфигурационном колбеке в структуре контекста модуля. <em>Наконец</em>, мы собираемся указать Nginx'у, где искать наш код. Балансировщики в этом вопросе особенные, их мы рассмотрим позже в разделе <a href="#load_balancers">Устройство балансировщиков нагрузки</a>.

<a name="handler-installation"></a>
<h4>2.5.1. Установка обработчика</h4>

Обработчики устанавливаются с помощью кода внутри колбеков, вызываемых директивами, которые относятся к модулю. Например, моя структура <code>ngx_command_t</code> из модуля circle_gif выглядит примерно так:

<pre><code class="cpp">
    { ngx_string("circle_gif"),
      NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
      ngx_http_circle_gif,
      0,
      0,
      NULL }
</code></pre>




Третьим аргументом как раз является колбек, в примере это <code>ngx_http_circle_gif</code>. Вспомним, что аргументами этого колбека являются: структура директивы (<code>ngx_conf_t</code>, в кторой сохранены параметры из конфигурационного файла), соответствующая структура <code>ngx_command_t</code> и указатель на структуру конфигурации модуля. В моем модуле circle_gif эта функция выглядит так:

<pre><code class="cpp">
static char *
ngx_http_circle_gif(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);
    clcf-&gt;handler = ngx_http_circle_gif_handler;

    return NGX_CONF_OK;
}
</code></pre>

 

 
Она выполняет работу в два этапа. Во-первых, получает внутреннюю структуру описывающую этот локешн. Во-вторых, устанавливает в ней обработчик (тоже колбек). Просто, не правда ли?

<a name="filter-installation"></a>
<h4>2.5.2. Установка фильтра</h4>
Фльтры устанавливаются на этапе постконфигурации. Бывает два типа фильтров: <em>фильтры заголовков</em> которые обрабатывают HTTP-заголовки, и <em>фильтры тела ответа</em>, которые обрабатывают собственно данные. Мы устанавливаем оба за один раз.

В качестве простого примера посмотрим на chunked-фильтр, его контекст выглядит так:

<pre><code class="cpp">
static ngx_http_module_t  ngx_http_chunked_filter_module_ctx = {
    NULL,                                  /* preconfiguration */
    ngx_http_chunked_filter_init,          /* postconfiguration */
  ...
};
</code></pre>

 

 
Вот что происходит в <code>ngx_http_chunked_filter_init</code>:

<pre><code class="cpp">static ngx_int_t
ngx_http_chunked_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_chunked_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_chunked_body_filter;

    return NGX_OK;
}
</code></pre>

 

 
Что это значит? Если вы помните, фильтры работают по принципу цепочки обязанностей. Когда обработчик сгенерирует ответ, он вызывает две функции: <code>ngx_http_output_filter</code>, которая вызывает глобальную <code>ngx_http_top_body_filter</code>; и <code>ngx_http_send_header</code>, вызывает другую глобальную <code>ngx_top_header_filter</code>.

Функции <code>ngx_http_top_body_filter</code> и <code>ngx_http_top_header_filter</code> являются гловными в цепочках фильтров соответственно заголовка и тела ответа. Каждое звено в цепи содержит ссылку на следующее звено (ссылки называются <code>ngx_http_next_body_filter</code> и <code>ngx_http_next_header_filter</code>). Когда фильтр закончит выполнение, он просто вызывает следующий, пока не будет вызван специальный фильтр, который уже заворачивает данные в HTTP-ответ. Все что делает функция filter_init, это добавляет свой модуль в обе эти цепи. Эта функция сохраняет ссылку на бывший первым фильтр в своей собственной переменной и определяет <em>свои</em> колбеки, как первые в цепочках. Цепочка действует по принципу LIFO (Last In Frist Out): последним добавлен — первым обработан.
<div class="aside">

Заметка на полях: а как точно это работает?
Каждый фильтр возвращает либо ошибку, либо результат специального выражения:
<code>return ngx_http_next_body_filter();</code>


Таким обазом, если очередь в цепочке фильтров дошла до последнего («специального») фильтра, просто возвращается "OK", но если проихошла ошибка, оставшаяся цепочка пропускается и Nginx выводит соответствующее сообщение об ошибке. Это простой однонаправленный список с бастрой обработкой ошибок, выполненный в виде указателей на функции. Превосходно.</div>
<a name="types"></a>
<h2>3. Обработчики, фильтры и балансировщики нагрузки</h2>
Теперь рассмотрим пару простейших модулей под микроскопом и разберемся как они работает

<a name="non-proxying"></a>
<h3>3.1. Устройство обработчиков (не проксирующих)</h3>
Обработчики, обычно, выполняют четыре шага: получают конфигурацию локешна, генерируют соответствующий ответ, отправляют заголовки и отправляют тело ответа. Хентдлер получает один аргумент: структуру запроса. В структуре запроса хранится много молезной информации о запросе клиента. Такой как, метод запроса, URI и загловки. Мы рассмотрим эти четыре шага один за другим.

<a name="non-proxying-config"></a>
<h4>3.1.1. Получение конфигурации локейшна</h4>
Это простая часть. Все, что надо сделать, это вызвать <code>ngx_http_get_module_loc_conf</code> и передать параметрами текущий запрос и описание модуля. Вот соответствующая часть хендлера из моего модуля circle_gif:

<pre><code class="cpp">
static ngx_int_t
ngx_http_circle_gif_handler(ngx_http_request_t *r)
{
    ngx_http_circle_gif_loc_conf_t  *circle_gif_config;
    circle_gif_config = ngx_http_get_module_loc_conf(r, ngx_http_circle_gif_module);
    ...
</code></pre>

 

 
Вот так я получил доступ ко всем переменным, сохраненным на этапе сливания конфигов.

<a name="non-proxying-response"></a>
<h4>3.1.2. Генерация ответа</h4>
Это та самая интересная часть, где модули делают полезную работу.
Нам поможет стуктура запроса, а именно эти ее свойства:

<pre><code class="cpp">
typedef struct {
...
/* пул памяти, используемый в функциях типа ngx_palloc */
    ngx_pool_t                       *pool;
    ngx_str_t                         uri;
    ngx_str_t                         args;
    ngx_http_headers_in_t             headers_in;

...
} ngx_http_request_t;
</code></pre>

 

 

<code>uri</code> это путь запроса, например "/query.cgi".

<code>args</code> содержит нераспарсенные параметры запроса (идущая за знаком вопроса часть), например "name=john".

<code>headers_in</code> хранит много полезной информации, такой как куки и информация о браузере, но большинству модулей эти данные не пригождаюися. Посмотрите <a class="source" href="http://www.riceonfire.org/lxr/http/source/http/ngx_http_request.h#L158">http/ngx_http_request.h</a>, если интересно.

Этого вполне достаточно, чтобы смочь составить какой-нибудь полезный ответ. Полное описание структуры <code>ngx_http_request_t</code> можно найти в <a class="source" href="http://www.riceonfire.org/lxr/http/source/http/ngx_http_request.h#L316">http/ngx_http_request.h</a>.

<a name="non-proxying-header"></a>
<h4>3.1.3. Отправка заголовков</h4>
Заголовки ответа живут в структуре называемой <code>headers_out</code>. Она в свою очередь хранится в структуре запроса. Обработчик хапроса выставляет те заголовки, которые ему надо и вызывает <code>ngx_http_send_header(r)</code>. Вот некоторые из самых полезный элементов <code>headers_out</code>:

<pre>
<code class="cpp">typedef stuct {
...
    ngx_uint_t                        status;
    size_t                            content_type_len;
    ngx_str_t                         content_type;
    ngx_table_elt_t                  *content_encoding;
    off_t                             content_length_n;
    time_t                            date_time;
    time_t                            last_modified_time;
..
} ngx_http_headers_out_t;
</code></pre>

 

 

Остальное можно найти в <a class="source" href="http://www.riceonfire.org/lxr/http/source/http/ngx_http_request.h#L220">http/ngx_http_request.h</a>.

Так, например, если модуль должен выставить Content-Type в "image/gif", Content-Length в 100 и вернуть код ответа 200 OK, то следующий код поможет ему сделать это:

<pre><code class="cpp">
    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = 100;
    r-&gt;headers_out.content_type.len = sizeof("image/gif") - 1;
    r-&gt;headers_out.content_type.data = (u_char *) "image/gif";
    ngx_http_send_header(r);
</code></pre>

 

 
Большинство стандартных загловоков HTTP доступны (где-либо) для изменения вами. Однако, некоторые хаголовки задать немного сложнее чем те, которые вы видели выше. На пример, <code>content_encoding</code> имеет тип <code>(ngx_table_elt_t*)</code>, поэтому модуль должен сам выделить память для этого заголовка. Это можно сделать с помощью функции <code>ngx_list_push</code>, которая принимает <code>ngx_list_t</code> (похож на массив) и возвращает указатель на вновь созданный элемен в этом списке (типа <code>ngx_table_elt_t</code>). Код ниже устанавливает заголовок Content-Encoding в значение "deflate" и отправляет заголовки:

<pre><code class="cpp">
    r-&gt;headers_out.content_encoding = ngx_list_push(&amp;r-&gt;headers_out.headers);
    if (r-&gt;headers_out.content_encoding == NULL) {
        return NGX_ERROR;
    }
    r-&gt;headers_out.content_encoding-&gt;hash = 1;
    r-&gt;headers_out.content_encoding-&gt;key.len = sizeof("Content-Encoding") - 1;
    r-&gt;headers_out.content_encoding-&gt;key.data = (u_char *) "Content-Encoding";
    r-&gt;headers_out.content_encoding-&gt;value.len = sizeof("deflate") - 1;
    r-&gt;headers_out.content_encoding-&gt;value.data = (u_char *) "deflate";
    ngx_http_send_header(r);
</code></pre>

 

 
Этот механизм, обычно, используется тогда, когда заголовок может иметь более одного значения одновременно. Этот прием (теоретически) позволяет фильтрам легче добавлять или удалять соответствующие значения, не изменяя другие, так как им не приходится заниматься работой со строками.

<a name="non-proxying-body"></a>
<h4>3.1.4. Отправка тела ответа</h4>

Теперь, когда модуль сгенерировал ответ и записал его в память, ему необходимо присвоить овет специальному буферу и затем, передать буфер в специальное <em>звено чепочки</em>, а <em>потом</em> вызвать «отправку ответа» на этом звене.

Зачем нужна звенья и цепочка? Nginx позволяет обработчикам генерировать (а фильтрам обрабатывать) ответ по одному буферу за раз. Каждое звено цепи хранит ссылку на следующие звен или <code>NULL</code> если оно последнее. Чтобы не усложнять пример, предстваим, что у нас есть только один буфер (и одно звено цепи).

Сначала модуль должен объявить буфер и звено цепи.

<pre><code class="cpp">
    ngx_buf_t    *b;
    ngx_chain_t   out;
</code></pre>


Следующим шагом надо выделить память для буфера и добавить его в данные ответа:

<pre><code class="cpp">
    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
    if (b == NULL) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
            "Не удалось выделить буфер ответа.");
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }

    b-&gt;pos = some_bytes; /* позиция первого байта в блоке данных */
    b-&gt;last = some_bytes + some_bytes_length; /* последняя позиция */

    b-&gt;memory = 1; /* данные храняться в памяти только для чтения */
    /* (то есть фильтры должны скопировать эти данные перед обработкой, вместо того, чтобы изменять их) */

    b-&gt;last_buf = 1; /* буферов в запросе больше не будет */
</code></pre>

 

 
А здесь модуль присваивает буфер звену цепи:

<pre><code class="cpp">
    out.buf = b;
    out.next = NULL;
</code></pre>

 

 

И наконец, мы отправляем ответ и возвращаем статут вызова отправки за один раз:

<pre><code class="cpp">
    return ngx_http_output_filter(r, &amp;out);
</code></pre>

 

 
Цепочки буферов — это критически важная часть модели ввода/вывода в Nginx'е, так что вы должны ими хорошо овладеть.
<div class="aside">

Очевидный вопрос: зачем буферу флаг <code>last_buf</code>, если мы можем определить, что он последний проверив "next" на <code>NULL</code>?

Ответ: цепь может быть незавершенной, то есть состоять из множества буферов, не не все буферы уже подготовлены в запросе или ответе. Таким образом, некоторые буферы будут в конце цепи, но не в конце запроса. И это приводит нас к…</div>
<h3>3.2. Устройство апстримов (они же прокси)</h3>
Продолжение следует.